### [1. 一元操作符](#1)

### [2. 布尔操作符（逻辑）](#2)

### [3. 乘性操作符](#3)

### [4. 加性操作符](#4)

### [5. 关系操作符](#5)

### [6. 相等操作符](#6)

### [7. 条件操作符](#7)

### [8. 赋值操作符](#8)

### [9. 逗号操作符](#9)

### [10. 举例](#10)

<h1 id="1"> 一、一元操作符</h1>

只能操作一个值的操作符叫一元操作符

<h4 id="1.1"> 1. 递增和递减操作符</h4>

- 前置型：`++(--)值`先递增(递减)，后执行语句
- 后置型：`值++(--)`先使用值执行语句，后递增(递减)
- 这四个操作符对任何值都适用，不仅适用与整数，还可用于字符串、布尔值、浮点数值和对象
- 应用于不同的值时，遵循下列规则
    - 在应用于一个包含有效数字的字符串时，先将其转化为数字值，在执行加减1的操作
        - eg: `var a = "3" // ++a = 4`
    - 在应用一个不包含有效数字的字符串时，将变量的值设为`NaN`
        - eg: `var a = "z" // a++ = NaN`
    - 在应用于布尔值时，先将其转换为数值变量，再执行加减1的操作
        - eg: `var a = false // a++ = 0`
    - 在应用于浮点数值时，执行加减1的操作
        - eg: `var a = 0.111 // --a = -0.889`
    - 在应用于对象时，先调用对象的`valueOf()`方法来取得一个可供操作的值，然后在对该值调用前述规则。如果结果是`NaN`，则在调用`toString()`方法后再应用前述规则。

```JavaScript
var a = 10;
console.log(a ++); //10  先输出再++
console.log(a); //11


console.log(++ a); //11   先++再输出

var a = 10;
var b = ++a - 1 + a ++; 
//运算是从左到右,运算最后的++后,虽然a变成了12但是最后面的++是先运算完成后再加,所以运算的时候a还是11 --> b=11-1+11 =21
console.log(b + ' ' + a);
//21 12

```

<h4 id="1.2"> 2. 一元加和减操作符 </h4>

- <h5>一元加操作符以一个加号(+)表示，放在数值前面</h5>
    - 应用于数值时，对数值不会产生任何影响
    - 在对非数值应用一元加操作符时，该操作符会像`Number()`转型函数一样对这个值执行转换
    - 布尔值会转换成 0 和 1，字符串值会按照一组特殊的规则进行解析，而对象是先调用它们的`valueOf()`和(或)`toString()`方法，在转换得到的值。

- <h5>一元减操作符(-)主要用于表示负数</h5>
    - 应用于数值时，表示负数
    - 应用于非数值时，一元减操作符与一元加操作符相同的规则，最后在将得到的数值转换为负数

```js
var a1="01";
var a2="1.1";
var a3="z";
var b=false;
var f=1.1;
var o={
    valueOf:function(){
        return -1;} 
    };
    
a1=+a1;//1
a2=+a2;//1.1
a3=+a3;//NaN
b=+b;//0
f=+f;//1.1
o=+o;//-1
```

<h1 id="2"> 二. 布尔操作符（逻辑）</h1>

逻辑运算符用于测定变量或值之间的逻辑。

<h5>eg: x=6 ,y=3</h5>

运算符 |	描述| 	例子
----|----|----
`&& `	|`and` |`	(x < 10 && y > 1) 为 true`
`\|\| `	|`or `	|`(x\==5 \|\| y\==5) 为 false`
`! `	|`not`| `	!(x==y) 为 true`

    转换成布尔值值被认定为 false 的是: undefined, null, NaN, "", 0, false // "" 空字符串

#### 1. 逻辑非(` ! `)

- 逻辑非( ! )可以应用于JavaScript中的任何值。无论这个值是什么类型，都将会返回一个布尔值
- 逻辑非操作符会先将它的操作数转换为一个布尔值，然后在对其求反

```js
console.log(!false); // true
console.log(!"blue"); // false
console.log(!0); // true
console.log(!NaN); // true
console.log(!""); // true
console.log(!12345); // false
```

#### 2. 逻辑与(`&&`)

第一个操作数|第二个操作数|结 果
:----:|:----:|:----:
`true`|`true`|`true`
`true`|`false`|`false`
`false`|`true`|`false`
`false`|`false`|`false`

- 逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值
- 运算结果为真实的值
- 逻辑与操作属于短路操作。即第一个操作数能决定结果，那就不会在对第二个操作数求值
- 对于逻辑与操作而言，如果第一个操作数是false，则不会继续对第二个操作数求值

```JavaScript
var a = 1 && 2 + 2; 
console.log(a); // 4
//第一个表达式转换成布尔值为true,那就会返回第二个表达式的结果.

var a = 0 && 2;
console.log(a); // 0
//第一个表达式转换成布尔值为false,那第二个表达式就不会看了,直接返回第一个表达式的值.
```

- 不能在逻辑与操作中使用未定义的值

- 跟 if 的用法一样，可以互相转换

```JS
var a =10;
var b =20;
var c;

if(a < b){
	console.log(c = a + b);
}   // 30
```

```JS
var a =10;
var b =20;
var c;

a < b && console.log(c = a +b); // 30
```

#### 3. 逻辑或(`||`)

第一个操作数|第二个操作数|结 果
:----:|:----:|:----:
`true`|`true`|`true`
`true`|`false`|`true`
`false`|`true`|`true`
`false`|`false`|`false`

- 两个操作数都为`false`，返回`false`；否则返回`true`
- 逻辑或操作也属于短路操作，第一个表达式转换成布尔值为 `true`，那就不会看后面，直接返回第一个表达式的结果
- 第一个表达式转换成布尔值为 `false`，那就会返回第二个表达式的结果
- 可以利用逻辑或来避免为变量赋值`null`或`undefined`值(转换布尔值是 false)
- 可以用在兼容上

<h1 id = "3"> 三. 乘性操作符</h1>

#### 在操作数为非数值时，会执行自动的类型转换.如果参与乘性计算的某个操作数不是数值，后台会先使用`Number()`转型函数将其转化为数值。即空字符串被当做0，布尔值`true`被当做为1

#### 1. 乘法(`*`)

- 乘法操作符（*），用于计算两个数值的乘积
- 在处理特殊值时，遵循下列规则
    - 如果操作数都是数值，执行常规的乘法计算。如果乘积超过了 JS 数值的表示范围，则返回 `Infinity` 或 `-Infinity`
    - 如果一个操作数是 `NaN`，则结果是 `NaN `
    - 如果`Infinity`与`0`相乘，则结果是`NaN`
    - 如果`Infinity`与`非0`数值相乘，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号
    - 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后再应用上面的规则

#### 2. 除法(`/`)

- 除法操作符（/）,执行第二个操作数除以第一个操作数的计算
- 在处理特殊值时，遵循下列规则
    - 如果操作数都是数值，执行常规的除法计算。如果商超过了 JavaScript 数值的表示范围，则返回`Infinity`或`-Infinity`
    - 如果一个操作数是`NaN`，则结果是`NaN`
    - 如果是`Infinity`被`Infinity`除，则结果是`NaN`
    - 如果是零被零除，则结果是`NaN`
    - 如果是非零的有限数被零除，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号
    - 如果是`Infinity`被任何非零数值除，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号
    - 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后应用上面的规则

#### 3. 求模(`%`)

- 求模（余数）操作符（%）
- 在处理特殊值时，遵循下列规则
    - 如果操作数都是数值，执行常规的除法计算，返回除得的余数
    - 如果被除数是无穷大值而除数是有限大的数值，则结果是`NaN`
    - 如果被除数是有限大的数值而除数是零，则结果是`NaN`
    - 如果是`Infinity`被`Infinity`除，则结果是`NaN`
    - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数
    - 如果被除数是零，则结果是零
    - 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后再应用上面的规则

```js
var e = 1 % 5;
console.log(e);
//0  商0余1
//6 % 5 -> 1 商1余1
//10 % 2 -> 商5余0
```

<h1 id="4"> 四. 加性操作符</h1>

#### 1. 加法(`+`)

- 如果两个操作符都是数值，则执行常规的加法计算
- 遵循下列规则
    - 如果有一个操作数是`NaN`，则结果是`NaN`
    - 如果是`Infinity`加`Infinity`，则结果是`Infinity`
    - 如果是`-Infinity`加`-Infinity`，则结果是`-Infinity`
    - 如果是`Infinity`加`-Infinity`，则结果是`NaN`
    - 如果是`+0`加`+0`，则结果是`+0`
    - 如果是`-0`加`-0`，则结果是`-0`
    - 如果是`+0`加`-0`，则结果是`+0`
    - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来
    - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
    - 如果一个操作数是对象、数值或布尔值，则调用它们的`toString()`方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于`undefined`和`null`，则分别调用`String()`函数并取得字符串`"undefined"`和`"null"`

```js
var result1 = 5 + 5;//两个数值相加
alert(result1);//10

var result2 = 5 + "5";//一个数值和一个字符串相加
alert(result2);//"55"
```
#### 2. 减法(`-`)

- 遵循下列规则
    - 如果两个操作数都是数值，则执行常规的算术减法操作并返回结果
    - 如果一个操作数是`NaN`,则结果是`NaN`
    - 如果是`Infinity`减`Infinity`，则结果是`NaN`
    - 如果是`-Infinity`减`-Infinity`，则结果是`NaN`
    - 如果是`Infinity`减`-Infinity`，则结果是`Infinity`
    - 如果是`-Infinity`减`Infinity`，则结果是`-Infinity`
    - 如果是`+0`减`+0`，则结果是`+0`
    - 如果是`-0`减`+0`，则结果是`-0`
    - 如果是`-0`减`-0`，则结果是`+0`
    - 如果有一个操作数是字符串、布尔值、`null`或`undefined`，则先在后台调用`Number()`函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是`NaN`，则减法的结果就是`NaN`
    - 如果有一个操作数是对象，则调用对象的`valueOf()`方法以取得表示该对象 的数值。如果得到的值是`NaN`，则减法的结果就是`NaN`。如果对象没有`valueOf()`方法，则调用其`toString()`方法并将得到的字符串转换为数值

```js
var result1=5-true;//4
var result2=NaN-1;//NaN
var result3=5-3;//2
var result4=5-"";//5
var result=5-"2";//3
var result=5-null;//5

```

<h1 id="5"> 五. 关系操作符</h1>

- <h5>小于（`<`）、大于（`>`）、小于等于（`<=`）和大于等于（`>=`）这几个关系操作符用于对两个值进行比较。这几个操作符都返回一个布尔值</h5>
- 操作非数值时，遵循下列规则
    - 如果这两个操作数都是数值，则执行数值比较
    - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
    - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较
    - 如果一个操作数是对象，则调用这个对象的`valueOf()`方法，并用得到的结果根据前面的规则执行比较
    - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较

<h1 id="6"> 六. 相等操作符</h1>

#### 1. 相等和不相等(`==`)

- 相等操作符（`==`），如果两个操作数相等，则返回`true`
- 不相等操作符（`!=`），如果两个操作数不相等，则返回`true`
- 这两个操作符都会先转换操作数（强制转型），然后再比较它们的相等性
- 转换不同数据类型时，遵循下列规则
    - 如果一个操作数是布尔值，则在比较相等性之前先将其转换为数值——`false`转换为`0`，`true`转换为`1`
    - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
    - 如果一个操作数是对象，另一个操作数不是，则调用对象的`valueOf()`方法，用得到的基本类型值按照前面的规则进行比较
- 两个操作符进行比较时，遵循下列规则
    - `null`和`undefined`是相等的
    - 要比较相等性之前，不能将`null`和`undefined`转换成其它任何值
    - 如果一个操作数是`NaN`，则相等操作符返回`false`，而不相等操作符返回`true`（即使两个操作数都是`NaN`，相等操作符返回`false`,因为按照规则，`NaN`不等于任何东西包括自己）
    - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`；否则，返回`false`


表达式| 值 | 表达式 | 值
:---:|:---:|:---:|:---:
`null==undefined` |	`true` |	`true==1` |	`true`
`"NaN"==NaN` |	`false` |	`true==2` |	`false`
`5==NaN `	|`false` |	`undefined==0` |`	false`
`NaN==NaN` |	`false `	|`null==0` |	`false`
`NaN!=NaN` |`	true `|	`"5"==5` |`	true`
`false==0` |	`true`

#### 2. 全等和不全等(`===`)

- 比较不转换操作数，全等和不全等操作符相同</h5>
- 全等操作符（`===`），只在两个操作数数据类型和值都相等的情况下返回`true`
- 不全等操作符（`！==`），在两个操作数数据类型和值都不相等的情况下返回`true`
- `null == undeifned`会返回`true`，因为它们是类似的值；但`null===undefined`会返回`false`，因为它们是不同类型的值

```js
var result1=("55"==55);//true,转换后相等
var result2=("55"===55);//false,不转换，字符串不等于数值

var result1=("55"!=55);//false,转换后相等
var result2=("55"!==55);//true,不转换，字符串不等于数值
```

<h1 id="7"> 七. 条件操作符</h1>

- 条件操作符非常灵活，即三元运算符
- `表达式？true:false`

```js
var max=(num1>num2)?num1:num2;
//如果num1>num2(关系表达式返回true),则将num1的值赋给max；
//如果num1小于或等于num2（关系表达式返回false），则将num2的值赋给max
```

<h1 id="8"> 八. 赋值操作符</h1>

- 赋值操作符（`=`），将右侧的值赋给左侧的变量
- 复合赋值操作符
    - 乘（`*`）赋值：`*=`
    - 除（`/`）赋值：`/=`
    - 模（`%`）赋值：`%=`
    - 加（`+`）赋值：`+=`
    - 减（`-`）赋值：`-=`
    - 左移（`<<`）:`<<=`
    - 有符号右移（`>>`）赋值：`>>=`
    - 无符号右移（`>>>`）赋值`：>>>=`
- 复合操作符主要目的是简化赋值运算，使用它们不会有任何性能的提升

<h1 id="9"> 九. 逗号操作符</h1>

- 使用逗号操作符(`,`)可以在一条语句中执行多个操作
- 逗号操作符多用于声明多个变量
- 在用于赋值时，逗号操作符总会返回表达式中的最后一项

```js
var num=(5,1,4,8,0);//num的值为0
//由于0是表达式中的最后一项，因此num的值就是0
```

<h1 id="10"> 十. 举例</h1>

### 01. 输入 a,b,c 三个数字，打印出最大的。

```js
var a = parseInt(window.prompt("input"));
var b = parseInt(window.prompt("input"));
var c = parseInt(window.prompt("input"));

if(a>b && a>c){
    document.write(a);
}else if (b>a && b>c){
    document.write(b);
}else{
    document.write(c);
}
```

### 02. 计算2的n次幂，n 可输入，n 为自然数。

```js
var n = parseInt(window.prompt("input"));

// 1 * 2    // n = 1
// 1 * 2 * 2    // n = 2
// 1 * 2 * 2 * 2    // n = 3
// 1 * 2 * 2 * 2 * 2    // n = 4

var a = 1;  // 然后就设置个变量 a = 1。

// 让乘的次数和 n 一样的话好理解，而且 1 乘任何数都无所谓。

if(n >= 0){
    for(var i = 0; i < n; i++){
        a *= 2;
    }
    document.write(a);
}else{
    document.write(n + "不是自然数");
}

```

### 03. 计算 n 的阶乘，n 可输入

```js
// 5! = 5 * 4 * 3 * 2 * 1
// 4! = 4 * 3 * 2 * 1

// 让多少的阶乘就乘多少次，这样好理解

// 5! = 5 * 4 * 3 * 2 * 1 * 1
// 4! = 4 * 3 * 2 * 1 * 1

var n = parseInt(window.prompt("input"));

var a = 1;    

for(var i = 1; i <= n ; i++){
    a = a * i;
}
document.write(a);
```

### 04. 求1-100之间的所有的质数。

```js
// 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

// 让每个数循环除以 1-100 之间的数只要能整除的次数是 2次 就说明只有自己和 1 才能整除，那这个数就是质数。

var count = 0;

for(var i = 1; i <= 100; i++){   
   
   for(var j = 1; j <= i; j++){   
      
      if(i % j == 0){   
         count ++;   // 求可以整除的次数
      }
   }

   if(count == 2){ 
      document.write(i + " ");   
   }
   count = 0;     // 重置整除的次数，以便循环的时候再利用。
}
```
```js
// 100   10 * 10
//       4 * 25
//       2 * 50
//       1 * 100
//       2.5 * 40

for(var i = 2; i <= 100; i++){   

   for(var j = 1; j <= Math.sqrt(i); j++){   
      
      if(i % j == 0){   
         count ++;   // 求可以整除的次数
      }
   }

   if(count == 1){ 
      document.write(i + " ");   
   }
   count = 0;     // 重置整除的次数，以便循环的时候再利用。
}
```

### 05. 求1-100之间能被3整除的所有数的和。

```js
var sum = 0;

for(var i = 1; i <= 100; i++){
  if(i%3 == 0){
    sum = sum + i;
  }
}
console.log(sum);   // 1683
```
### 06. 斐波那契数列

```js
// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 输出第n项

// 1.定义三个变量，一个变量是数列第一项值，一个变量是第二项值，一个变量是中间变量；
// 2.为了依次得到之后的值，也就是最开始的第二项值变成了之后的第一项值（需要把之前的第二项值存储在中间变量中），
//之后的第二项值变成了之前两项值的和。

// f s t
// 1 1 2 3 5 8
//   f s t

// 第一次运算 f + s = t 然后首先将 s 赋值给 f 让它变成新 f ，再将 t 赋值给 s 让它变成新 s 。


//  n - 2 = 运算多少次

var n = parseInt(window.prompt("input"));


var t;
var f = 1;
var s = 1;

if(n > 2){
  for(var i = 0; i < n - 2; i++){
    t = f + s;
    f = s;
    s = t;
  }
  document.write(t);
}else{
  document.write(1);
}

```

### 07. 运算符练习

```js
// 输入1个三位数，反向输出

var n = parseInt(window.prompt("input"));

var a,b,c;

a = n % 10; // 提取三位数中的个位数
b = (n % 100)-a ; // 提取 三位数中的十位数
c = n - (n %100); // 提取三位数中的百位数
var m = a*100 + b + c/100;

document.write(m);

```

### 08. 类型转换

```js
var str = false + 1;
console.log(str); // 1

var demo = false == 1; //false == 1 的结果赋值给 demo
console.log(demo);  // false

if(typeof(a) && -true + (+undefined) + ''){ // +undefined => NaN // 无法转换成数字就是 NaN
    document.write('基础扎实'); // 两边都是字符串可以执行
}
// typeof(a) => "undefined"
// -1 + NaN + '' => 'NaN'

if(11 + "11" * 2 == 33){    // "11" * 2 => 22 // 除了 + 以外的数学运算两边都会自动转换成数字
    document.write('基础扎实');
}

!!" " + !!"" - !!false||document.write('你觉得能打印，你就是猪')；
// true + false - false => 1 + 0 - 0 = 1
// 因为前面是 1 就是真，直接就不看后面的，所以无法打印。
```
