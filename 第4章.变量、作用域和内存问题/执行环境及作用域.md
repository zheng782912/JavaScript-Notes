# 执行上下文

在JavaScript中有三种代码运行环境:  

* Global Code  
　　JavaScript代码开始运行的默认环境  
* Function Code  
　　代码进入一个JavaScript函数  
* Eval Code  
　　使用eval()执行代码  

为了表示不同的运行环境，JavaScript中有一个`执行上下文（Execution context，EC）`的概念。也就是说，当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文就构成了一个`执行上下文栈（Execution context stack，ECS）`。

例如对如下面的JavaScript代码:  
```javascript
var a = "global var";

function foo(){
    console.log(a);
}

function outerFunc(){
    var b = "var in outerFunc";
    console.log(b);
    
    function innerFunc(){
        var c = "var in innerFunc";
        console.log(c);
        foo();
    }
    innerFunc();
}

outerFunc()

//var in outerFunc
//var in innerFunc
//global var
```
代码首先进入Global Execution Context，然后依次进入outerFunc，innerFunc和foo的执行上下文，执行上下文栈就可以表示为:  
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025201151427-127726802.png)  
当JavaScript代码执行的时候，第一个进入的总是默认的Global Execution Context，所以说它总是在ECS的最底部.  

对于每个Execution Context都有三个重要的属性，变量对象（Variable object，VO），作用域链（Scope chain）和this。这三个属性跟代码运行的行为有很重要的关系，下面会一一介绍.

当然，除了这三个属性之外，根据实现的需要，Execution Context还可以有一些附加属性.  
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025201152849-1821016303.png)  

## VO和AO
从上面看到，在Execution Context中，会保存变量对象（Variable object，VO），下面就看看变量对象是什么。  
### 变量对象（Variable object）  
变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。也就是说，一般VO中会包含以下信息：  
* 变量 (var, Variable Declaration);
* 函数声明 (Function Declaration, FD);
* 函数的形参  

当JavaScript代码运行中，如果试图寻找一个变量的时候，就会首先查找VO。对于前面例子中的代码，Global Execution Context中的VO就可以表示如下：  
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025201154239-918576092.png)  

注意，假如上面的例子代码中有下面两个语句，Global VO仍将不变。  
```javascript
(function bar(){}) // function expression, FE
baz = "property of global object"
```
也就是说，对于VO，是有下面两种特殊情况的：
* 函数表达式（与函数声明相对）不包含在VO之中
* 没有使用var声明的变量（这种变量是，"全局"的声明方式，只是给Global添加了一个属性，并不在VO中）

### 活动对象（Activation object）

只有全局上下文的变量对象允许通过VO的属性名称间接访问；在函数执行上下文中，VO是不能直接访问的，此时由激活对象(Activation Object,缩写为AO)扮演VO的角色。激活对象 是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。  

Arguments Objects 是函数上下文里的激活对象AO中的内部对象，它包括下列属性：
1. callee：指向当前函数的引用
2. length： 真正传递的参数的个数
3. properties-indexes：就是函数的参数值(按参数列表从左到右排列)

对于VO和AO的关系可以理解为，VO在不同的Execution Context中会有不同的表现：当在Global Execution Context中，可以直接使用VO；但是，在函数Execution Context中，AO就会被创建。  

当上面的例子开始执行outerFunc的时候，就会有一个outerFunc的AO被创建：  
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025201156317-195051519.png)  


通过上面的介绍，我们现在了解了VO和AO是什么，以及他们之间的关系了。下面就需要看看JavaScript解释器是怎么执行一段代码，以及设置VO和AO了。  

## 细看Execution Context  
当一段JavaScript代码执行的时候，JavaScript解释器会创建Execution Context，其实这里会有两个阶段：
* 创建阶段（当函数被调用，但是开始执行函数内部代码之前)  
  * 创建Scope chain
  * 创建VO/AO（variables, functions and arguments）
  * 设置this的值  
* 激活/代码执行阶段
  * 设置变量的值、函数的引用，然后解释/执行代码  

这里想要详细介绍一下"创建VO/AO"中的一些细节，因为这些内容将直接影响代码运行的行为。  

对于"创建VO/AO"这一步，JavaScript解释器主要做了下面的事情：

* 根据函数的参数，创建并初始化arguments object
* 扫描函数内部代码，查找函数声明（Function declaration）
  * 对于所有找到的函数声明，将函数名和函数引用存入VO/AO中
  * **如果VO/AO中已经有同名的函数，那么就进行覆盖** 
* 扫描函数内部代码，查找变量声明（Variable declaration）
  * 对于所有找到的变量声明，将变量名存入VO/AO中，并初始化为"undefined"
  * 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性  

看下面的例子：  
```javascript
function foo(i) {
    var a = 'hello';
    var b = function privateB() {

    };
    function c() {

    }
}

foo(22);
```

对于上面的代码，在"创建阶段"，可以得到下面的Execution Context object：
```javascript
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: undefined,
        b: undefined
    },
    this: { ... }
}
```
在"激活/代码执行阶段"，Execution Context object就被更新为：
```javascript
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: 'hello',
        b: pointer to function privateB()
    },
    this: { ... }
}
```
## 例子分析:  
### Example 1
```javascript
(function(){
    console.log(bar);
    console.log(baz);
    
    var bar = 20;
    
    function baz(){
        console.log("baz");
    }
    
})()
//undefined
//function baz(){console.log("baz:)};
```

**代码解释**：匿名函数会首先进入"创建结果"，JavaScript解释器会创建一个"Function Execution Context"，然后创建Scope chain，VO/AO和this。根据前面的介绍，解释器会扫描函数和变量声明，如下的AO会被创建： 

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025201158208-1634029739.png)  

所以，对于bar，我们会得到"undefined"这个输出，表现的行为就是，我们在声明一个变量之前就访问了这个变量。这个就是JavaScript中**声明提升"Hoisting"**。

### Example 2
接着上面的例子，进行一些修改：  
```javascript
(function(){
    //console.log(bar); 输出会错误,因为下面的bar不是用var声明的.
    console.log(baz);
    
    bar = 20;
    console.log(window.bar);
    console.log(bar);
    
    function baz(){
        console.log("baz");
    }
    
})()
//function baz(){console.log("baz:)};
//20
//20
```  
### Example 3  
```javascript
(function(){
    console.log(foo);
    console.log(bar);
    console.log(baz);
    
    var foo = function(){};
    
    function bar(){
        console.log("bar");
    }
    
    var bar = 20;
    console.log(bar);
    
    function baz(){
        console.log("baz");
    }
    
})()
//function bar(){console.log("bar:)};
//function baz(){console.log("baz:)};
//20
```  
代码中，最"奇怪"的地方应该就是"bar"的输出了，第一次是一个函数，第二次是"20"。  

其实也很好解释，回到前面对"创建VO/AO"的介绍，在创建VO/AO过程中，`先是处理arguments, 参数，接着是函数的声明，最后是变量的声明`。解释器会先扫描函数声明，然后"bar:<function>"就被保存在了AO中；解释器扫描变量声明的时候，虽然发现"var bar =20;"，但是因为"bar"在AO中已经存在，所以就没有任何操作了。  

但是，当代码执行到第二句"console.log(bar);"的时候，"激活/代码执行阶段"已经把AO中的"bar"重新设置了。  


## 作用域链(scope chain)

### 作用域

开始介绍作用域链之前，先看看JavaScript中的作用域（scope）。在很多语言中（C++，C#，Java），作用域都是通过代码块（由{}包起来的代码）来决定的，**但是，在JavaScript作用域是跟函数相关的，也可以说成是function-based**。

例如，当for循环这个代码块结束后，依然可以访问变量"i"。  
```javascript
for(var i = 0; i < 3; i++){
    console.log(i);
}

console.log(i); //3
```
对于作用域，又可以分为`全局作用域（Global scope）`和`局部作用域（Local scpoe）`。

**全局作用域**中的对象可以在代码的任何地方访问，一般来说，下面情况的对象会在全局作用域中：
* 最外层函数和在最外层函数外面定义的变量
* 没有通过关键字"var"声明的变量
* 浏览器中，window对象的属性

**局部作用域**又被称为函数作用域（Functionscope），所有的变量和函数只能在作用域内部使用。
```javascript
var foo = 1;
window.bar = 2;

function baz(){
    a = 3;
    var b = 4;
}
// Global scope: foo, bar, baz, a 
// Local scope: b
```
### 作用域链

通过前面一篇文章了解到，每一个ExecutionContext中都有一个VO，用来存放变量，函数和参数等信息。

在JavaScript代码运行中，所有用到的变量都需要去当前AO/VO中查找，当找不到的时候，就会继续查找上层Execution Context中的AO/VO。这样一级级向上查找的过程，就是所有Execution Context中的AO/VO组成了一个作用域链。

所以说，**作用域链**与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。

`Scope = VO/AO + All Parent VO/AOs`  

看一个例子：
```javascript
var x = 10;

function foo() {
    var y = 20;
    
    function bar() {
        var z = 30;
       
        console.log(x + y + z);
    };
    
    bar()
};

foo();
//60
```
上面代码的输出结果为"60"，函数bar可以直接访问"z"，然后通过作用域链访问上层的"x"和"y"。

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/593627-20151025202341552-94941711.png)

* 棕色箭头指向VO/AO
* 蓝色箭头指向scope chain（VO/AO + All Parent VO/AOs）

再看一个比较典型的例子：
```javascript
var data = [];
for(var i = 0 ; i < 3; i++){
    data[i]=function() {
        console.log(i);
    }
}

data[0]();// 3
data[1]();// 3
data[2]();// 3
```
第一感觉（错觉）这段代码会输出"0，1，2"。但是根据前面的介绍，变量"i"是存放在"Global VO"中的变量，循环结束后"i"的值就被设置为3，所以代码最后的三次函数调用访问的是相同的"Global VO"中已经被更新的"i"。


### 作用域链和自由变量

各个作用域的嵌套关系组成了一条作用域链。例子中bar函数保存的作用域链是bar -> fn -> 全局，fn函数保存的作用域链是fn -> 全局

使用作用域链主要是进行标识符的查询，标识符解析就是沿着作用域链一级一级地搜索标识符的过程，而作用域链就是要保证对变量和函数的有序访问.

1. 如果自身作用域中声明了该变量，则无需使用作用域链.
```javascript

var a = 1;
var b = 2;
function fn(x){
    var a = 10;
    function bar(x){
        var a = 100;
        b = x + a;
        return b;
    }
    bar(20);
    bar(200);
}
fn(0);
//100
```
2. 如果自身作用域中未声明该变量，则需要使用作用域链进行查找
#
    这时，就引出了另一个概念——自由变量。在当前作用域中存在但未在当前作用域中声明的变量叫自由变量
在下面的例子中，如果要在bar函数中查询变量b，由于b并没有在当前作用域中声明，所以b是自由变量。bar函数的作用域链是bar -> fn -> 全局。到上一级fn作用域中查找b没有找到，继续到再上一级全局作用域中查找b，找到了b
```javascript
var a = 1;
var b = 2;
function fn(x){
    var a = 10;
    function bar(x){
        var a = 100;
        b = x + a;
        return b;
    }
    bar(20);
    bar(200);
}
fn(0);
```

# 执行上下文&作用域
一定要区分执行环境和变量对象。执行环境会随着函数的调用和返回，不断的重建和销毁。但变量对象在有变量引用(如闭包)的情况下，将留在内存中不被销毁

在下面的例子中，存在着全局作用域，fn作用域和bar作用域，它们相互嵌套

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731172935747-825467613.jpg)

    这是例子中的代码执行到第15行时fn(0)函数的执行环境，执行环境里的变量对象保存了fn()函数作用域内所有的变量和函数的值
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731170459184-333032646.jpg)

### 执行流
代码的执行顺序叫做**执行流**，程序源代码并不是按照代码的书写顺序一行一行往下执行，而是和函数的调用顺序有关.

例子中的执行流是第1行 -> 第2行 -> 第4行 -> 第15行 -> 第5行 -> 第7行 -> 第12行 -> 第8行 -> 第9行 -> 第10行 -> 第11行 -> 第13行 -> 第8行 -> 第9行 -> 第10行 -> 第11行 -> 第14行

### 执行环境栈
执行环境栈类似于作用域链，有序地保存着当前程序中存在的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。javascript程序中的执行流正是由这个机制控制着

在例子中，当执行流进入bar(20)函数时，当前程序的执行环境栈如下图所示，其中黄色的bar(20)执行环境表示当前程序正处此执行环境中

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731170955934-224535512.jpg)

当bar(20)函数执行完成后，当前程序的执行环境栈如下图所示，bar(20)函数的执行环境被销毁，等待垃圾回收，控制权交还给黄色背景的fn(0)执行环境

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731171053638-673292359.jpg)

### 说明:

下面按照代码执行流的顺序对该图示进行详细说明

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731172935747-825467613.jpg)

    1.代码执行流进入全局执行环境，并对全局执行环境中的代码进入声明提升(hoisting)
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731190902091-37243179.jpg)

    2.执行流执行第1行代码var a =1;，对a进行LHS查询，给a赋值1；执行流执行第2行代码var b = 2;，对b进行LHS查询，给b赋值2
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731191345091-639743696.jpg)

    3.执行流执行第15行代码fn(0);，调用fn(0)函数，此时执行流进入fn(0)函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参0赋值给形参x中。此时执行环境栈中存在两个执行环境，fn(0)函数为当前执行流所在执行环境
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731191514184-1957937741.jpg)

    4.执行流执行第5行代码var a = 10;，对a进行LHS查询，给a赋值10
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731191649184-1598135181.jpg)

    5.执行流执行第12行代码bar(20);，调用bar(20)函数，此时执行流进入bar(20)函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参20赋值给形参x中。此时执行环境栈中存在三个执行环境，bar(20)函数为当前执行流所在执行环境.

    在声明提升的过程中，由于b是个自由变量，需要通过bar()函数的作用域链bar() -> fn() -> 全局作用域进行查找，最终在全局作用域中也就是代码第2行找到var b = 2;，然后在全局执行环境中找到b的值是2，所以给b赋值2
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002255808-17114336.png)

    6.执行流执行第8行代码var a = 100;，给a赋值100；执行流执行第9行b = x + a;，对x进行RHS查询，找到x的值是20，对a进行RHS查询，找到a的值是100，所以通过计算b的值是120，给b赋值120；执行第10行代码return b;，对b进行RHS查询，找到b的值是120，所以函数返回值为120
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002340433-694885172.png)

    7.执行流执行完第10行代码后，bar(20)的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给fn(0)函数的执行环境
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002414011-617228933.png)

    8.执行流执行第13行代码bar(200);，调用bar(200)函数，此时执行流进入bar(200)函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参200赋值给形参x中。此时执行环境栈中存在三个执行环境，bar(200)函数为当前执行流所在执行环境
    
    与第5步相同，在声明提升的过程中，由于b是个自由变量，需要通过bar()函数的作用域链bar() -> fn() -> 全局作用域进行查找，最终在全局作用域中也就是代码第2行找到更新后的var b = 120，然后在全局执行环境中找到b的值是120，所以给b赋值120
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002440699-1731397510.png)

    9.与第6步相同，执行流执行第8行代码var a = 100;，给a赋值100；执行流执行第9行b = x + a;，对x进行RHS查询，找到x的值是200，对a进行RHS查询，找到a的值是100，所以通过计算b的值是300，给b赋值300；执行第10行代码return b;，对b进行RHS查询，找到b的值是300，所以函数返回值为300
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002529746-1209359330.png)

    10.执行流执行完第10行代码后，bar(200)的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给fn(0)函数的执行环境
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002559902-82238802.png)

    11.执行流执行第14行代码}，fn(0)的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给全局执行环境
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002615605-2034483675.png)

    12.当页面关闭时，全局执行环境被销毁，页面再无执行环境
![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20160731193710356-1478533484.jpg)

![](https://raw.githubusercontent.com/zheng782912/Javascript-study-notes/master/images/Chapter-4/740839-20170825002012605-1886151430.png)


# 总结

1. javascript使用的是词法作用域。对于函数来说，词法作用域是在函数定义时就已经确定了，与函数是否被调用无关。通过作用域，可以知道作用域范围内的变量和函数有哪些，却不知道变量的值是什么。所以作用域是静态的

    **通过eval()函数和with语句可以对作用域进行动态修改**
2. 对于函数来说，执行环境是在函数调用时确定的，执行环境包含作用域内所有变量和函数的值。在同一作用域下，不同的调用(如传递不同的参数)会产生不同的执行环境，从而产生不同的变量的值。所以执行环境是动态的
